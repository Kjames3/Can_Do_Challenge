<!DOCTYPE html>
<html lang="en">

<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Viam Rover Control Panel</title>
    <meta name="description" content="Control panel for Viam-powered rover with camera, lidar, and object detection">

    <link rel="preconnect" href="https://fonts.googleapis.com">
    <link rel="preconnect" href="https://fonts.gstatic.com" crossorigin>
    <link href="https://fonts.googleapis.com/css2?family=Inter:wght@400;500;600;700&display=swap" rel="stylesheet">

    <!-- Three.js for 3D Visualization (r128 - last version with classic JS support) -->
    <script src="https://cdn.jsdelivr.net/npm/three@0.128.0/build/three.min.js"></script>
    <script src="https://cdn.jsdelivr.net/npm/three@0.128.0/examples/js/controls/OrbitControls.js"></script>

    <style>
        /* =================================================================
           CSS Variables & Reset
           ================================================================= */
        :root {
            --bg-primary: #0f172a;
            --bg-secondary: #1e293b;
            --bg-tertiary: #334155;
            --bg-hover: #475569;

            --text-primary: #f8fafc;
            --text-secondary: #94a3b8;
            --text-muted: #64748b;

            --accent-cyan: #06b6d4;
            --accent-cyan-dark: #0891b2;
            --accent-green: #22c55e;
            --accent-red: #ef4444;
            --accent-yellow: #eab308;
            --accent-purple: #a855f7;

            --border-color: #475569;
            --shadow-lg: 0 10px 40px rgba(0, 0, 0, 0.4);

            --radius-sm: 6px;
            --radius-md: 10px;
            --radius-lg: 16px;

            --transition: 0.2s ease;
        }

        *,
        *::before,
        *::after {
            box-sizing: border-box;
            margin: 0;
            padding: 0;
        }

        html,
        body {
            height: 100%;
        }

        body {
            font-family: 'Inter', -apple-system, BlinkMacSystemFont, sans-serif;
            background: var(--bg-primary);
            color: var(--text-primary);
            line-height: 1.5;
            overflow-x: hidden;
        }

        /* =================================================================
           Layout
           ================================================================= */
        .app-container {
            max-width: 1600px;
            margin: 0 auto;
            padding: 1.5rem;
            min-height: 100%;
        }

        /* =================================================================
           Header
           ================================================================= */
        .header {
            display: flex;
            align-items: center;
            justify-content: space-between;
            flex-wrap: wrap;
            gap: 1rem;
            margin-bottom: 1.5rem;
            padding-bottom: 1.5rem;
            border-bottom: 1px solid var(--border-color);
        }

        .header-title {
            display: flex;
            align-items: center;
            gap: 0.75rem;
        }

        .header-title h1 {
            font-size: 1.75rem;
            font-weight: 700;
            background: linear-gradient(135deg, var(--accent-cyan), var(--accent-purple));
            -webkit-background-clip: text;
            -webkit-text-fill-color: transparent;
            background-clip: text;
        }

        .header-title .logo {
            width: 40px;
            height: 40px;
            background: linear-gradient(135deg, var(--accent-cyan), var(--accent-purple));
            border-radius: var(--radius-md);
            display: flex;
            align-items: center;
            justify-content: center;
            font-size: 1.25rem;
        }

        .connection-status {
            display: flex;
            align-items: center;
            gap: 1rem;
        }

        .status-indicator {
            display: flex;
            align-items: center;
            gap: 0.5rem;
            padding: 0.5rem 1rem;
            background: var(--bg-secondary);
            border-radius: var(--radius-md);
            font-size: 0.875rem;
        }

        .status-dot {
            width: 10px;
            height: 10px;
            border-radius: 50%;
            background: var(--accent-red);
            animation: pulse 2s infinite;
        }

        .status-dot.connected {
            background: var(--accent-green);
        }

        .status-dot.connecting {
            background: var(--accent-yellow);
        }

        /* Power Stats */
        .power-readout {
            display: flex;
            gap: 1rem;
            align-items: center;
            background: var(--bg-tertiary);
            padding: 0.5rem 1rem;
            border-radius: var(--radius-md);
            border: 1px solid var(--border-color);
            margin-right: 1rem;
        }

        .power-item {
            display: flex;
            flex-direction: column;
            align-items: flex-end;
            line-height: 1.1;
        }

        .power-item small {
            font-size: 0.65rem;
            color: var(--text-muted);
            text-transform: uppercase;
        }

        .power-item span {
            font-family: 'SF Mono', 'Monaco', monospace;
            font-size: 0.9rem;
            font-weight: 700;
            color: var(--accent-cyan);
        }

        .separator {
            width: 1px;
            height: 20px;
            background: var(--border-color);
        }

        @keyframes pulse {

            0%,
            100% {
                opacity: 1;
            }

            50% {
                opacity: 0.5;
            }
        }

        /* =================================================================
           Buttons
           ================================================================= */
        .btn {
            display: inline-flex;
            align-items: center;
            justify-content: center;
            gap: 0.5rem;
            padding: 0.625rem 1.25rem;
            font-family: inherit;
            font-size: 0.875rem;
            font-weight: 600;
            border: none;
            border-radius: var(--radius-md);
            cursor: pointer;
            transition: all var(--transition);
        }

        .btn:disabled {
            opacity: 0.6;
            cursor: not-allowed;
        }

        .btn-primary {
            background: linear-gradient(135deg, var(--accent-cyan), var(--accent-cyan-dark));
            color: white;
        }

        .btn-primary:hover:not(:disabled) {
            transform: translateY(-1px);
            box-shadow: 0 4px 12px rgba(6, 182, 212, 0.3);
        }

        .btn-danger {
            background: linear-gradient(135deg, var(--accent-red), #dc2626);
            color: white;
        }

        .btn-danger:hover:not(:disabled) {
            transform: translateY(-1px);
            box-shadow: 0 4px 12px rgba(239, 68, 68, 0.3);
        }

        /* =================================================================
           Cards
           ================================================================= */
        .card {
            background: var(--bg-secondary);
            border-radius: var(--radius-lg);
            border: 1px solid var(--border-color);
            overflow: hidden;
            transition: all var(--transition);
        }

        .card-header {
            display: flex;
            align-items: center;
            justify-content: space-between;
            padding: 1rem 1.25rem;
            background: var(--bg-tertiary);
            border-bottom: 1px solid var(--border-color);
        }

        .card-header h2 {
            font-size: 1rem;
            font-weight: 600;
            display: flex;
            align-items: center;
            gap: 0.5rem;
        }

        .card-header .icon {
            font-size: 1.25rem;
        }

        .card-body {
            padding: 1.25rem;
        }

        /* WASD Control Panel */
        .wasd-panel {
            background: var(--bg-secondary);
            border-radius: 16px;
            padding: 1rem;
            display: flex;
            flex-direction: column;
            align-items: center;
            gap: 1rem;
            width: 100%;
            max-width: 220px;
            border: 1px solid var(--border-color);
        }

        .control-header {
            display: flex;
            justify-content: space-between;
            align-items: center;
            width: 100%;
            font-size: 0.85rem;
            font-weight: 600;
            color: var(--text-secondary);
        }

        .d-pad {
            display: grid;
            grid-template-columns: repeat(3, 1fr);
            grid-template-rows: repeat(2, 1fr);
            gap: 8px;
            margin: 0.5rem 0;
        }

        .d-btn {
            width: 48px;
            height: 48px;
            background: var(--bg-tertiary);
            border: 1px solid var(--border-color);
            border-radius: 8px;
            color: var(--text-primary);
            display: flex;
            align-items: center;
            justify-content: center;
            cursor: pointer;
            transition: all 0.1s;
            font-size: 1.2rem;
            user-select: none;
        }

        .d-btn:active,
        .d-btn.active {
            background: var(--accent-cyan);
            color: #000;
            transform: translateY(2px);
        }

        /* Specific positions */
        #btn-w {
            grid-column: 2;
            grid-row: 1;
        }

        #btn-a {
            grid-column: 1;
            grid-row: 2;
        }

        #btn-s {
            grid-column: 2;
            grid-row: 2;
        }

        #btn-d {
            grid-column: 3;
            grid-row: 2;
        }

        .power-setting {
            width: 100%;
            display: flex;
            flex-direction: column;
            gap: 0.5rem;
        }

        .power-val {
            font-family: monospace;
            color: var(--accent-green);
        }

        /* reuse slider styling for horizontal power slider */
        input[type=range].h-slider {
            -webkit-appearance: none;
            width: 100%;
            height: 6px;
            background: var(--bg-tertiary);
            border-radius: 3px;
        }

        input[type=range].h-slider::-webkit-slider-thumb {
            -webkit-appearance: none;
            width: 16px;
            height: 16px;
            background: var(--text-primary);
            border-radius: 50%;
            cursor: pointer;
        }

        /* =================================================================
           Toggle Switch
           ================================================================= */
        .toggle-wrapper {
            display: flex;
            align-items: center;
            gap: 0.75rem;
        }

        .toggle-label {
            font-size: 0.875rem;
            color: var(--text-secondary);
        }

        .toggle {
            position: relative;
            width: 48px;
            height: 26px;
            background: var(--bg-tertiary);
            border-radius: 13px;
            cursor: pointer;
            transition: all var(--transition);
        }

        .toggle::after {
            content: '';
            position: absolute;
            top: 3px;
            left: 3px;
            width: 20px;
            height: 20px;
            background: white;
            border-radius: 50%;
            transition: all var(--transition);
        }

        .toggle.active {
            background: var(--accent-cyan);
        }

        .toggle.active::after {
            left: 25px;
        }

        /* =================================================================
           Grid Layout
           ================================================================= */
        .main-grid {
            display: grid;
            grid-template-columns: 1fr;
            gap: 1.5rem;
        }

        @media (min-width: 992px) {
            .main-grid {
                grid-template-columns: 3fr 2fr;
            }
        }

        @media (min-width: 1400px) {
            .main-grid {
                grid-template-columns: 2fr 1fr;
            }
        }

        .sidebar {
            display: flex;
            flex-direction: column;
            gap: 1.5rem;
        }

        /* =================================================================
           Camera Feed
           ================================================================= */
        .camera-feed {
            width: 100%;
            aspect-ratio: 16 / 9;
            object-fit: contain;
            background: #000;
            border-radius: var(--radius-md);
        }

        .camera-placeholder {
            width: 100%;
            aspect-ratio: 16 / 9;
            display: flex;
            align-items: center;
            justify-content: center;
            background: var(--bg-tertiary);
            border-radius: var(--radius-md);
            color: var(--text-muted);
            font-size: 0.875rem;
        }

        /* =================================================================
           Detection Panel
           ================================================================= */
        .detection-panel {
            margin-top: 1rem;
            padding: 1rem;
            background: var(--bg-tertiary);
            border-radius: var(--radius-md);
        }

        .detection-header {
            display: flex;
            align-items: center;
            justify-content: space-between;
            margin-bottom: 1rem;
        }

        .detection-count {
            font-size: 0.875rem;
            color: var(--text-secondary);
        }

        .detection-count strong {
            color: var(--accent-cyan);
            font-size: 1.25rem;
        }

        .detection-list {
            display: flex;
            flex-direction: column;
            gap: 0.5rem;
            max-height: 200px;
            overflow-y: auto;
        }

        .detection-item {
            display: flex;
            align-items: center;
            justify-content: space-between;
            padding: 0.75rem;
            background: var(--bg-secondary);
            border-radius: var(--radius-sm);
            font-size: 0.8125rem;
        }

        .detection-item-label {
            display: flex;
            align-items: center;
            gap: 0.5rem;
        }

        .detection-badge {
            padding: 0.25rem 0.5rem;
            background: var(--accent-cyan);
            color: white;
            border-radius: var(--radius-sm);
            font-size: 0.75rem;
            font-weight: 600;
            text-transform: capitalize;
        }

        .detection-item-stats {
            display: flex;
            gap: 1rem;
            color: var(--text-secondary);
        }

        .confidence-bar {
            width: 50px;
            height: 6px;
            background: var(--bg-tertiary);
            border-radius: 3px;
            overflow: hidden;
        }

        .confidence-fill {
            height: 100%;
            background: var(--accent-green);
            border-radius: 3px;
            transition: width var(--transition);
        }

        .no-detections {
            text-align: center;
            padding: 1.5rem;
            color: var(--text-muted);
            font-size: 0.875rem;
        }

        /* =================================================================
           Motor Readouts
           ================================================================= */
        .motor-grid {
            display: grid;
            grid-template-columns: 1fr 1fr;
            gap: 1rem;
        }

        .motor-card {
            text-align: center;
            padding: 1rem;
            background: var(--bg-tertiary);
            border-radius: var(--radius-md);
        }

        .motor-card h3 {
            font-size: 0.75rem;
            font-weight: 600;
            color: var(--accent-cyan);
            text-transform: uppercase;
            letter-spacing: 0.5px;
            margin-bottom: 0.75rem;
        }

        .motor-value {
            font-size: 1.5rem;
            font-weight: 700;
            font-family: 'SF Mono', 'Monaco', monospace;
        }

        .motor-label {
            font-size: 0.75rem;
            color: var(--text-muted);
            margin-top: 0.25rem;
        }

        /* =================================================================
           Motor Controls
           ================================================================= */
        .control-section {
            display: flex;
            flex-direction: column;
            align-items: center;
            gap: 1.5rem;
        }

        .sliders-container {
            display: flex;
            justify-content: center;
            gap: 3rem;
            width: 100%;
        }

        .slider-group {
            display: flex;
            flex-direction: column;
            align-items: center;
            gap: 0.5rem;
        }

        .slider-label {
            font-size: 0.875rem;
            font-weight: 600;
            color: var(--text-secondary);
        }

        /* Custom Vertical Range Input */
        .vertical-slider {
            -webkit-appearance: none;
            width: 80px;
            /* Wider as requested */
            height: 300px;
            /* Taller */
            background: transparent;
            cursor: pointer;
            writing-mode: bt-lr;
            /* IE/Edge */
            -webkit-appearance: slider-vertical;
            /* Webkit */
            appearance: slider-vertical;
            /* Note: "appearance: slider-vertical" often overrides standard styling. 
               For a truly custom look matching the image (pill shape, fill), 
               we often need a wrapper or simpler cross-browser tricks. 
               However, standard range with rotation or vertical orient is tricky. 
               Let's try a transform approach for maximum styling control if native vertical fails styling.
               Actually, standard practice for "pill" sliders is often rotated horizontal sliders 
               OR just standard vertical inputs with limited styling. 
               Given "High Quality", I will use a rotated horizontal slider approach via a wrapper 
               to ensure I can get the "track" and "fill" look exactly right on all browsers. 
             */
            display: none;
            /* We will replace the visible inputs with our custom structure below, 
                             or strictly style these if possible. */
        }

        /* 
           Simulating Vertical Sliders using Rotated Inputs is often more reliable for styling 
           than 'appearance: slider-vertical'. 
        */

        .slider-wrapper {
            position: relative;
            width: 80px;
            height: 300px;
            background: var(--bg-secondary);
            border-radius: 40px;
            box-shadow: inset 0 2px 6px rgba(0, 0, 0, 0.3);
            display: flex;
            align-items: center;
            justify-content: center;
            border: 2px solid var(--border-color);
        }

        .slider-fill {
            position: absolute;
            bottom: 0;
            left: 0;
            right: 0;
            background: linear-gradient(to top, var(--accent-green), #4ade80);
            border-radius: 40px;
            opacity: 0.8;
            pointer-events: none;
            /* Height set by JS */
            height: 50%;
            transition: height 0.1s ease, background-color 0.2s;
        }

        .slider-input {
            position: absolute;
            width: 300px;
            /* Height of the wrapper */
            height: 80px;
            /* Width of the wrapper */
            transform: rotate(-90deg);
            transform-origin: center;
            opacity: 0;
            /* Invisible interaction layer */
            cursor: pointer;
            z-index: 2;
        }

        /* Thumb visualization (optional, if we want a separate thumb element) */
        .slider-thumb {
            position: absolute;
            left: 50%;
            width: 70px;
            height: 70px;
            background: #e2e8f0;
            border: 2px solid #cbd5e1;
            border-radius: 20px;
            transform: translate(-50%, 50%);
            /* Start centered vertically */
            bottom: 50%;
            /* Adjusted by JS */
            pointer-events: none;
            box-shadow: 0 4px 6px rgba(0, 0, 0, 0.2);
            z-index: 1;
            transition: bottom 0.1s ease;
        }

        .slider-value {
            font-family: 'SF Mono', 'Monaco', monospace;
            font-size: 1.25rem;
            font-weight: 700;
            color: var(--text-primary);
            margin-top: 1rem;
        }

        #auto-drive-wrapper {
            width: 100%;
            transition: all 0.3s ease;
            overflow: hidden;
            max-height: 0;
            /* Hidden by default */
            opacity: 0;
        }

        #auto-drive-wrapper.visible {
            max-height: 200px;
            opacity: 1;
            margin-top: 1rem;
        }

        .stop-btn {
            width: 120px;
            height: 120px;
            border-radius: 50%;
            background: linear-gradient(145deg, var(--accent-red), #b91c1c);
            border: 4px solid #991b1b;
            color: white;
            font-size: 1.5rem;
            font-weight: 700;
            cursor: pointer;
            transition: all var(--transition);
            box-shadow: 0 8px 24px rgba(239, 68, 68, 0.3);
        }

        .stop-btn:hover {
            transform: scale(1.05);
            box-shadow: 0 12px 32px rgba(239, 68, 68, 0.4);
        }

        .stop-btn:active {
            transform: scale(0.98);
        }

        /* =================================================================
           Lidar
           ================================================================= */
        .lidar-container {
            display: flex;
            flex-direction: column;
            align-items: center;
        }

        .lidar-canvas {
            width: 100%;
            max-width: 300px;
            aspect-ratio: 1;
            background: #000;
            border-radius: var(--radius-md);
        }

        .lidar-scale {
            margin-top: 0.5rem;
            font-size: 0.75rem;
            color: var(--text-muted);
        }

        /* =================================================================
           Controller Status
           ================================================================= */
        .controller-status {
            display: flex;
            align-items: center;
            gap: 0.75rem;
            padding: 0.75rem 1rem;
            background: var(--bg-tertiary);
            border-radius: var(--radius-md);
            font-size: 0.875rem;
        }

        .controller-icon {
            font-size: 1.25rem;
        }

        .controller-info {
            flex: 1;
        }

        .controller-info-name {
            font-weight: 500;
        }

        .controller-info-hint {
            font-size: 0.75rem;
            color: var(--text-muted);
        }

        /* =================================================================
           Utilities
           ================================================================= */
        .mt-1 {
            margin-top: 0.5rem;
        }

        .mt-2 {
            margin-top: 1rem;
        }

        .text-muted {
            color: var(--text-muted);
        }

        .text-secondary {
            color: var(--text-secondary);
        }

        .disabled-overlay {
            opacity: 0.4;
            pointer-events: none;
        }

        /* =================================================================
           Scrollbar
           ================================================================= */
        ::-webkit-scrollbar {
            width: 6px;
        }

        ::-webkit-scrollbar-track {
            background: var(--bg-tertiary);
            border-radius: 3px;
        }

        ::-webkit-scrollbar-thumb {
            background: var(--bg-hover);
            border-radius: 3px;
        }

        ::-webkit-scrollbar-thumb:hover {
            background: var(--text-muted);
        }
    </style>
</head>

<body>
    <div class="app-container">
        <!-- Header -->
        <header class="header">
            <div class="header-title">
                <div class="logo">ü§ñ</div>
                <h1>Viam Rover Control</h1>
            </div>

            <div class="connection-status">
                <div id="power-stats" class="power-readout" style="display: none;">
                    <div class="power-item">
                        <small>Volts</small>
                        <span id="stat-volts">-- V</span>
                    </div>
                    <div class="separator"></div>
                    <div class="power-item">
                        <small>Amps</small>
                        <span id="stat-amps">-- A</span>
                    </div>
                    <div class="separator"></div>
                    <div class="power-item">
                        <small>Power</small>
                        <span id="stat-watts">-- W</span>
                    </div>
                    <div class="separator"></div>
                    <div class="power-item">
                        <small>Session</small>
                        <span id="stat-uptime">0:00</span>
                    </div>
                    <div class="separator"></div>
                    <div class="power-item" id="time-remaining-container">
                        <small>Time Left</small>
                        <span id="stat-time-remaining" style="color: var(--accent-green);">OK</span>
                    </div>
                </div>

                <!-- Controller Status -->
                <div id="gamepad-indicator" class="status-indicator" style="background: var(--bg-tertiary);">
                    <span style="font-size: 1.2rem;">üéÆ</span>
                    <span id="gamepad-status-text" style="color: var(--text-muted);">No Controller</span>
                </div>

                <div class="status-indicator">
                    <span id="status-dot" class="status-dot"></span>
                    <span id="status-text">Disconnected</span>
                </div>
                <!-- IP Input -->
                <input type="text" id="robot-ip" placeholder="Robot IP" value="192.168.1.X"
                    style="padding: 0.5rem; border-radius: var(--radius-md); border: 1px solid var(--border-color); background: var(--bg-tertiary); color: var(--text-primary); margin-right: 0.5rem; width: 140px;">
                <button id="connect-btn" class="btn btn-primary">Connect</button>
                <button id="disconnect-btn" class="btn btn-danger"
                    style="display: none; margin-left: 0.5rem;">Disconnect</button>
            </div>
        </header>

        <!-- Main Content -->
        <div class="main-grid">
            <!-- Left Column: Camera & Detection -->
            <div>
                <div class="card">
                    <div class="card-header">
                        <h2><span class="icon">üìπ</span> Camera Feed</h2>
                        <div style="display: flex; align-items: center; gap: 1rem;">
                            <button id="capture-btn" class="btn btn-primary"
                                style="padding: 0.4rem 0.8rem; font-size: 0.75rem;" title="Capture image for training">
                                üì∏ Capture
                            </button>
                            <span id="capture-count" style="font-size: 0.75rem; color: var(--text-secondary);">0
                                saved</span>
                            <div class="toggle-wrapper">
                                <span class="toggle-label">Detection</span>
                                <div id="detection-toggle" class="toggle" title="Toggle object detection"></div>
                            </div>
                        </div>
                    </div>
                    <div class="card-body">
                        <img id="camera-feed" class="camera-feed" alt="Camera feed" style="display: none;">
                        <div id="camera-placeholder" class="camera-placeholder">
                            Waiting for camera feed...
                        </div>

                        <!-- FPS Display Overlay -->
                        <div id="fps-display" class="fps-display"
                            style="display: none; margin-top: 0.5rem; padding: 0.5rem; background: var(--bg-tertiary); border-radius: var(--radius-sm); font-family: monospace;">
                            <span style="color: var(--success);">üì∑ Camera: <strong id="fps-camera">0</strong>
                                FPS</span>
                            <span id="fps-detection-wrapper" style="margin-left: 1rem; display: none;">
                                <span style="color: var(--warning);">üîç YOLO: <strong id="fps-detection">0</strong>
                                    FPS</span>
                            </span>
                        </div>

                        <!-- Detection Results -->
                        <div id="detection-panel" class="detection-panel" style="display: none;">
                            <div class="detection-header">
                                <span class="detection-count">
                                    <strong id="detection-count">0</strong> objects detected
                                </span>
                            </div>
                            <div id="detection-list" class="detection-list">
                                <div class="no-detections">No objects detected</div>
                            </div>
                        </div>
                    </div>
                </div>

                <!-- Motor Controls -->
                <div class="card mt-2">
                    <div class="card-header">
                        <h2><span class="icon">üéÆ</span> Motor Control</h2>
                    </div>
                    <div class="card-body">
                        <div class="control-section">
                            <div class="sliders-container">
                                <div class="slider-group">
                                    <span class="slider-label">LEFT</span>
                                    <div class="slider-wrapper">
                                        <div class="slider-fill" id="left-fill" style="bottom: 50%; height: 0%;"></div>
                                        <div class="slider-thumb" id="left-thumb" style="bottom: 50%;"></div>
                                        <input type="range" id="left-slider" class="slider-input" min="-100" max="100"
                                            value="0" step="1">
                                    </div>
                                    <span id="left-slider-value" class="slider-value">0</span>
                                </div>

                                <div
                                    style="display: flex; flex-direction: column; gap: 1rem; align-items: center; z-index: 10;">
                                    <button id="stop-btn" class="stop-btn">STOP</button>
                                    <div id="auto-drive-wrapper">
                                        <button id="auto-drive-btn" class="btn btn-primary" style="width: 100%;">
                                            Start Auto-Drive
                                        </button>
                                    </div>

                                    <!-- WASD Panel -->
                                    <div class="wasd-panel">
                                        <div class="control-header">
                                            <span>Quick move</span>
                                            <div style="display:flex; gap:0.5rem; align-items:center;">
                                                <small style="font-size:0.7rem;">WASD</small>
                                                <label class="switch">
                                                    <input type="checkbox" id="keyboard-toggle">
                                                    <span class="slider round"></span>
                                                </label>
                                            </div>
                                        </div>

                                        <div class="d-pad">
                                            <button class="d-btn" id="btn-w">‚Üë</button>
                                            <button class="d-btn" id="btn-a">‚Ü∂</button>
                                            <button class="d-btn" id="btn-s">‚Üì</button>
                                            <button class="d-btn" id="btn-d">‚Ü∑</button>
                                        </div>

                                        <div class="power-setting">
                                            <div style="display:flex; justify-content:space-between; font-size:0.8rem;">
                                                <span>Power</span>
                                                <span id="key-power-val" class="power-val">0.5</span>
                                            </div>
                                            <input type="range" id="key-power" class="h-slider" min="0.1" max="1.0"
                                                step="0.1" value="0.5">
                                        </div>
                                    </div>
                                </div>

                                <div class="slider-group">
                                    <span class="slider-label">RIGHT</span>
                                    <div class="slider-wrapper">
                                        <div class="slider-fill" id="right-fill" style="bottom: 50%; height: 0%;"></div>
                                        <div class="slider-thumb" id="right-thumb" style="bottom: 50%;"></div>
                                        <input type="range" id="right-slider" class="slider-input" min="-100" max="100"
                                            value="0" step="1">
                                    </div>
                                    <span id="right-slider-value" class="slider-value">0</span>
                                </div>
                            </div>

                            <!-- Controller Status -->
                            <div id="controller-status" class="controller-status">
                                <span class="controller-icon">üéÆ</span>
                                <div class="controller-info">
                                    <div id="controller-name" class="controller-info-name text-muted">No controller
                                        detected</div>
                                    <div class="controller-info-hint">üïπÔ∏è Right Stick: Drive ‚Ä¢ ‚úñ E-Stop ‚Ä¢ ‚óª Detection ‚Ä¢
                                        ‚ñ≥ Auto-Drive</div>
                                </div>
                            </div>
                        </div>
                    </div>
                </div>
            </div>
        </div>

        <!-- Right Column: Sidebar -->
        <div class="sidebar" id="control-area">
            <!-- Motor Readouts -->
            <div class="card">
                <div class="card-header">
                    <h2><span class="icon">üìä</span> Motor Status</h2>
                </div>
                <div class="card-body">
                    <div class="motor-grid">
                        <div class="motor-card">
                            <h3>Left Motor</h3>
                            <div id="left-pos" class="motor-value">0.00</div>
                            <div class="motor-label">Position (rev)</div>
                            <div id="left-power" class="motor-value mt-1">0%</div>
                            <div class="motor-label">Power</div>
                        </div>
                        <div class="motor-card">
                            <h3>Right Motor</h3>
                            <div id="right-pos" class="motor-value">0.00</div>
                            <div class="motor-label">Position (rev)</div>
                            <div id="right-power" class="motor-value mt-1">0%</div>
                            <div class="motor-label">Power</div>
                        </div>
                    </div>
                </div>
            </div>

            <!-- Position Display -->
            <div class="card">
                <div class="card-header">
                    <h2><span class="icon"></span> Position</h2>
                </div>
                <div class="card-body">
                    <div class="motor-grid">
                        <div class="motor-card">
                            <h3>Robot</h3>
                            <div id="robot-x" class="motor-value" style="font-size: 1rem;">X: 0.0</div>
                            <div id="robot-y" class="motor-value" style="font-size: 1rem;">Y: 0.0</div>
                            <div id="robot-theta" class="motor-value"
                                style="font-size: 0.85rem; color: var(--text-secondary);">Œ∏: 0.0¬∞</div>
                        </div>
                        <div class="motor-card">
                            <h3>Target</h3>
                            <div id="target-x" class="motor-value" style="font-size: 1rem;">X: --</div>
                            <div id="target-y" class="motor-value" style="font-size: 1rem;">Y: --</div>
                            <div id="target-dist" class="motor-value"
                                style="font-size: 0.85rem; color: var(--accent-green);">Dist: --</div>
                        </div>
                    </div>
                </div>
            </div>

            <!-- Lidar -->
            <div class="card">
                <div class="card-header">
                    <h2><span class="icon">üì°</span> Lidar View</h2>
                    <div class="toggle-wrapper">
                        <span class="toggle-label">Enable</span>
                        <div id="lidar-toggle" class="toggle"></div>
                    </div>
                </div>
                <div class="card-body">
                    <div class="lidar-container">
                        <canvas id="lidar-canvas" class="lidar-canvas" width="300" height="300"></canvas>
                        <span class="lidar-scale">100px = 1 meter</span>
                    </div>
                </div>
            </div>

            <!-- 3D Visualization (Three.js) -->
            <div id="viewport-3d-card" class="card">
                <div class="card-header">
                    <h2><span class="icon">üéÆ</span> 3D View</h2>
                    <div id="nav-phase-display"
                        style="font-size: 0.75rem; color: var(--accent-cyan); font-family: monospace;">IDLE</div>
                </div>
                <div class="card-body" style="padding: 0;">
                    <div id="viewport-3d-container" style="width: 100%; height: 300px; position: relative;">
                        <canvas id="viewport-3d-canvas" style="width: 100%; height: 100%;"></canvas>
                    </div>
                    <div
                        style="display: flex; gap: 1rem; padding: 0.5rem 1rem; font-size: 0.7rem; color: var(--text-muted); background: var(--bg-tertiary);">
                        <span>üîµ Robot</span>
                        <span style="color: #22c55e;">üü¢ Start</span>
                        <span style="color: #ef4444;">üî¥ Target</span>
                        <span style="color: #64748b;">‚¨ú Grid = 1m</span>
                    </div>
                </div>
            </div>
        </div>
    </div>
    </div>

    <script>
        // =================================================================
        // Application State
        // =================================================================
        const state = {
            ws: null,
            connected: false,
            detectionEnabled: false,
            lidarEnabled: false,
            gamepadIndex: null,
            lastLeftPower: 0,
            lastRightPower: 0,
            isAutoDriving: false
        };

        // Get Pi address from URL input or default to current hostname
        // This allows connecting to Pi when GUI is served from the same host
        // or manually entering Pi IP in the connection input
        const DEFAULT_PORT = 8081;

        function getServerAddress() {
            const hostInput = document.getElementById('robot-ip');
            if (hostInput && hostInput.value && hostInput.value !== '192.168.1.X') {
                return `ws://${hostInput.value}:${DEFAULT_PORT}`;
            }
            // Fallback: use localhost if running locally
            return `ws://localhost:${DEFAULT_PORT}`;
        }

        // =================================================================
        // Three.js 3D Visualization
        // =================================================================
        let scene3D, camera3D, renderer3D, controls3D;
        let robotMesh, targetMarker, startMarker;
        let robotTrailPoints = [];
        const MAX_TRAIL_POINTS = 200;

        function init3DViewport() {
            const container = document.getElementById('viewport-3d-container');
            const canvas = document.getElementById('viewport-3d-canvas');

            if (!container || !canvas || typeof THREE === 'undefined') {
                console.warn('Three.js not loaded or container not found');
                return;
            }

            // Scene
            scene3D = new THREE.Scene();
            scene3D.background = new THREE.Color(0x1e293b);

            // Camera (looking down at 45 degrees)
            camera3D = new THREE.PerspectiveCamera(60, container.clientWidth / container.clientHeight, 0.1, 1000);
            camera3D.position.set(0, 2, 2);
            camera3D.lookAt(0, 0, 0);

            // Renderer
            renderer3D = new THREE.WebGLRenderer({ canvas: canvas, antialias: true });
            renderer3D.setSize(container.clientWidth, container.clientHeight);
            renderer3D.setPixelRatio(window.devicePixelRatio);

            // Orbit Controls
            controls3D = new THREE.OrbitControls(camera3D, renderer3D.domElement);
            controls3D.enableDamping = true;
            controls3D.dampingFactor = 0.1;
            controls3D.maxPolarAngle = Math.PI / 2.1;  // Prevent going below ground

            // Ground Grid (1 meter = 100cm per square)
            const gridHelper = new THREE.GridHelper(5, 50, 0x475569, 0x334155);  // 5m x 5m, 10cm spacing
            scene3D.add(gridHelper);

            // Lighting
            const ambientLight = new THREE.AmbientLight(0xffffff, 0.6);
            scene3D.add(ambientLight);
            const directionalLight = new THREE.DirectionalLight(0xffffff, 0.8);
            directionalLight.position.set(2, 4, 2);
            scene3D.add(directionalLight);

            // Robot Model - Simple box geometry (no STL loading to avoid CORS issues)
            const robotMaterial = new THREE.MeshStandardMaterial({ color: 0x06b6d4, metalness: 0.3, roughness: 0.7 });

            // Box: width(X) x height(Y) x depth(Z) - Z is forward direction
            // Rover is wider than it is long, so width > depth
            const boxGeometry = new THREE.BoxGeometry(0.25, 0.08, 0.15);  // 25cm wide x 8cm tall x 15cm long
            robotMesh = new THREE.Mesh(boxGeometry, robotMaterial);
            robotMesh.position.set(0, 0.04, 0);
            scene3D.add(robotMesh);

            // Direction indicator (arrow pointing forward along +Z axis)
            const arrowGeom = new THREE.ConeGeometry(0.03, 0.08, 8);
            const arrowMat = new THREE.MeshStandardMaterial({ color: 0xffffff });
            const arrow = new THREE.Mesh(arrowGeom, arrowMat);
            // Cone default points along +Y, rotate -90¬∞ around X to point along +Z
            arrow.rotation.x = -Math.PI / 2;
            arrow.position.set(0, 0.04, 0.11);  // At front center of robot (half of depth + arrow length)
            robotMesh.add(arrow);

            // Start Marker (Green Disc)
            const startGeom = new THREE.CylinderGeometry(0.05, 0.05, 0.01, 16);
            const startMat = new THREE.MeshStandardMaterial({ color: 0x22c55e });
            startMarker = new THREE.Mesh(startGeom, startMat);
            startMarker.position.set(0, 0.005, 0);
            scene3D.add(startMarker);

            // Target Marker (Red Cylinder)
            const targetGeom = new THREE.CylinderGeometry(0.08, 0.08, 0.2, 16);
            const targetMat = new THREE.MeshStandardMaterial({ color: 0xef4444, transparent: true, opacity: 0.7 });
            targetMarker = new THREE.Mesh(targetGeom, targetMat);
            targetMarker.position.set(1, 0.1, 0.5);  // Default position
            targetMarker.visible = false;  // Hidden until target detected
            scene3D.add(targetMarker);

            // Animation loop
            function animate() {
                requestAnimationFrame(animate);
                controls3D.update();
                renderer3D.render(scene3D, camera3D);
            }
            animate();

            // Handle resize
            window.addEventListener('resize', () => {
                if (container && camera3D && renderer3D) {
                    camera3D.aspect = container.clientWidth / container.clientHeight;
                    camera3D.updateProjectionMatrix();
                    renderer3D.setSize(container.clientWidth, container.clientHeight);
                }
            });

            console.log('‚úì 3D Viewport initialized');
        }

        function update3DScene(robotPose, targetPose, navPhase) {
            if (!robotMesh) return;

            // Update robot position (convert cm to meters)
            robotMesh.position.x = robotPose.x / 100;
            robotMesh.position.z = robotPose.y / 100;

            // Update robot rotation (theta is heading, Three.js Y axis is up)
            robotMesh.rotation.y = -robotPose.theta;

            // Update target marker
            if (targetPose && targetPose.x !== null && targetPose.y !== null) {
                targetMarker.position.x = targetPose.x / 100;
                targetMarker.position.z = targetPose.y / 100;
                targetMarker.visible = true;
            } else {
                targetMarker.visible = false;
            }

            // Update nav phase display
            const navPhaseDisplay = document.getElementById('nav-phase-display');
            if (navPhaseDisplay && navPhase) {
                navPhaseDisplay.textContent = navPhase;
            }
        }

        // Initialize 3D viewport when DOM is ready
        document.addEventListener('DOMContentLoaded', () => {
            setTimeout(init3DViewport, 100);  // Small delay to ensure Three.js is loaded
        });

        // =================================================================
        // DOM Elements
        // =================================================================
        const elements = {
            // Connection
            connectBtn: document.getElementById('connect-btn'),
            statusDot: document.getElementById('status-dot'),
            statusText: document.getElementById('status-text'),
            controlArea: document.getElementById('control-area'),

            // Camera & Detection
            cameraFeed: document.getElementById('camera-feed'),
            cameraPlaceholder: document.getElementById('camera-placeholder'),
            detectionToggle: document.getElementById('detection-toggle'),
            detectionPanel: document.getElementById('detection-panel'),
            detectionCount: document.getElementById('detection-count'),
            detectionList: document.getElementById('detection-list'),
            autoDriveBtn: document.getElementById('auto-drive-btn'),

            // Power Stats
            powerStatsPanel: document.getElementById('power-stats'),
            statVolts: document.getElementById('stat-volts'),
            statAmps: document.getElementById('stat-amps'),
            statWatts: document.getElementById('stat-watts'),



            // Lidar
            lidarToggle: document.getElementById('lidar-toggle'),
            lidarCanvas: document.getElementById('lidar-canvas'),
            lidarCtx: document.getElementById('lidar-canvas').getContext('2d'),

            // Motors
            leftSlider: document.getElementById('left-slider'),
            leftSliderValue: document.getElementById('left-slider-value'),
            leftFill: document.getElementById('left-fill'),
            leftThumb: document.getElementById('left-thumb'),

            rightSlider: document.getElementById('right-slider'),
            rightSliderValue: document.getElementById('right-slider-value'),
            rightFill: document.getElementById('right-fill'),
            rightThumb: document.getElementById('right-thumb'),

            stopBtn: document.getElementById('stop-btn'),

            // Image Capture
            captureBtn: document.getElementById('capture-btn'),
            captureCount: document.getElementById('capture-count'),

            autoDriveWrapper: document.getElementById('auto-drive-wrapper'),

            // WSAD / D-Pad
            btnW: document.getElementById('btn-w'),
            btnA: document.getElementById('btn-a'),
            btnS: document.getElementById('btn-s'),
            btnD: document.getElementById('btn-d'),
            keyboardToggle: document.getElementById('keyboard-toggle'),
            keyPower: document.getElementById('key-power'),
            keyPowerVal: document.getElementById('key-power-val'),

            leftPos: document.getElementById('left-pos'),
            leftPower: document.getElementById('left-power'),
            rightPos: document.getElementById('right-pos'),
            rightPower: document.getElementById('right-power'),

            // Controller
            controllerName: document.getElementById('controller-name'),

            // Disconnect button
            disconnectBtn: document.getElementById('disconnect-btn'),

            // Trajectory (legacy - may not exist if using 3D viewport)
            trajectoryCard: document.getElementById('trajectory-card'),
            trajectoryCanvas: document.getElementById('trajectory-canvas'),
            trajectoryCtx: document.getElementById('trajectory-canvas')?.getContext('2d') || null,
            trajectoryOverlay: document.getElementById('trajectory-overlay'),
            trajectoryContainer: document.getElementById('trajectory-container'),

            // Position Display
            robotX: document.getElementById('robot-x'),
            robotY: document.getElementById('robot-y'),
            robotTheta: document.getElementById('robot-theta'),
            targetX: document.getElementById('target-x'),
            targetY: document.getElementById('target-y'),
            targetDist: document.getElementById('target-dist'),

            // Session & Battery Timer
            statUptime: document.getElementById('stat-uptime'),
            statTimeRemaining: document.getElementById('stat-time-remaining'),
            timeRemainingContainer: document.getElementById('time-remaining-container')
        };

        // =================================================================
        // WebSocket Connection
        // =================================================================
        function connect() {
            if (state.ws && state.ws.readyState === WebSocket.OPEN) return;

            updateConnectionStatus('connecting');
            const serverUrl = getServerAddress();
            console.log(`Connecting to ${serverUrl}`);
            state.ws = new WebSocket(serverUrl);

            state.ws.onopen = () => {
                state.connected = true;
                state.sessionStartTime = Date.now();
                updateConnectionStatus('connected');
                elements.controlArea.classList.remove('disabled-overlay');

                // Start session timer (updates every second)
                if (state.sessionTimerInterval) clearInterval(state.sessionTimerInterval);
                state.sessionTimerInterval = setInterval(() => {
                    if (!state.connected) return;
                    const elapsed = Math.floor((Date.now() - state.sessionStartTime) / 1000);
                    const mins = Math.floor(elapsed / 60);
                    const secs = elapsed % 60;
                    if (elements.statUptime) {
                        elements.statUptime.textContent = `${mins}:${secs.toString().padStart(2, '0')}`;
                    }
                }, 1000);
            };

            state.ws.onclose = () => {
                state.connected = false;
                updateConnectionStatus('disconnected');
                elements.controlArea.classList.add('disabled-overlay');
                state.ws = null;
            };

            state.ws.onerror = () => {
                state.connected = false;
                updateConnectionStatus('error');
                elements.controlArea.classList.add('disabled-overlay');
                state.ws = null;
            };

            state.ws.onmessage = (event) => {
                try {
                    const data = JSON.parse(event.data);
                    if (data.type === "readout") {
                        handleReadout(data);
                    } else if (data.type === "capture_response") {
                        // Update capture count display
                        elements.captureCount.textContent = `${data.count} saved`;
                    }
                } catch (e) {
                    console.error("Message parse error:", e);
                }
            };
        }

        function updateConnectionStatus(status) {
            elements.statusDot.className = 'status-dot';

            switch (status) {
                case 'connected':
                    elements.statusDot.classList.add('connected');
                    elements.statusText.textContent = 'Connected';
                    elements.connectBtn.textContent = 'Connected';
                    elements.connectBtn.disabled = true;
                    elements.disconnectBtn.style.display = 'inline-flex';
                    break;
                case 'connecting':
                    elements.statusDot.classList.add('connecting');
                    elements.statusText.textContent = 'Connecting...';
                    elements.connectBtn.textContent = 'Connecting...';
                    elements.connectBtn.disabled = true;
                    break;
                case 'error':
                    elements.statusText.textContent = 'Connection failed';
                    elements.connectBtn.textContent = 'Retry';
                    elements.connectBtn.disabled = false;
                    break;
                default:
                    elements.statusText.textContent = 'Disconnected';
                    elements.connectBtn.textContent = 'Connect';
                    elements.connectBtn.disabled = false;
                    elements.disconnectBtn.style.display = 'none';
            }
        }

        function sendMessage(data) {
            if (state.ws && state.ws.readyState === WebSocket.OPEN) {
                state.ws.send(JSON.stringify(data));
            }
        }

        // =================================================================
        // Data Handlers
        // =================================================================
        function handleReadout(data) {
            // Update motor readouts
            elements.leftPos.textContent = data.left_pos.toFixed(2);
            elements.leftPower.textContent = `${Math.round(data.left_power * 100)}%`;
            elements.rightPos.textContent = data.right_pos.toFixed(2);
            elements.rightPower.textContent = `${Math.round(data.right_power * 100)}%`;

            // Update camera feed
            if (data.image) {
                elements.cameraFeed.src = "data:image/jpeg;base64," + data.image;
                elements.cameraFeed.style.display = 'block';
                elements.cameraPlaceholder.style.display = 'none';
            }

            // Update FPS display
            const fpsDisplay = document.getElementById('fps-display');
            const fpsCameraEl = document.getElementById('fps-camera');
            const fpsDetectionEl = document.getElementById('fps-detection');
            const fpsDetectionWrapper = document.getElementById('fps-detection-wrapper');

            if (data.fps_camera !== undefined && fpsDisplay) {
                fpsDisplay.style.display = 'block';
                fpsCameraEl.textContent = data.fps_camera.toFixed(1);

                // Show YOLO FPS only when detection is enabled
                if (data.detection_enabled && data.fps_detection !== undefined) {
                    fpsDetectionWrapper.style.display = 'inline';
                    fpsDetectionEl.textContent = data.fps_detection.toFixed(1);
                } else {
                    fpsDetectionWrapper.style.display = 'none';
                }
            }

            // Update detections
            if (data.detections !== undefined) {
                updateDetections(data.detections);
            }

            // Update detection toggle state from server
            if (data.detection_enabled !== undefined) {
                state.detectionEnabled = data.detection_enabled;
                elements.detectionToggle.classList.toggle('active', state.detectionEnabled);
                elements.detectionPanel.style.display = state.detectionEnabled ? 'block' : 'none';
            }

            // Update Auto-Driving Button State
            if (data.is_auto_driving !== undefined) {
                state.isAutoDriving = data.is_auto_driving;
                updateAutoDriveButton();
            }

            // Update lidar
            if (data.lidar_points && state.lidarEnabled) {
                drawLidar(data.lidar_points);
            }

            // Update Battery / Power Stats
            if (data.battery) {
                elements.powerStatsPanel.style.display = 'flex';
                const voltage = data.battery.voltage;
                elements.statVolts.textContent = voltage.toFixed(2) + ' V';
                elements.statAmps.textContent = data.battery.amps.toFixed(3) + ' A';
                elements.statWatts.textContent = data.battery.watts.toFixed(2) + ' W';

                // Battery time remaining calculation
                // Threshold: 12.2V = rover will shutdown in ~2-3 minutes
                const LOW_VOLTAGE_THRESHOLD = 12.2;
                const CRITICAL_VOLTAGE = 11.8;  // Rover dies at ~11.8V

                if (voltage <= LOW_VOLTAGE_THRESHOLD && elements.timeRemainingContainer) {
                    elements.timeRemainingContainer.style.display = 'block';

                    // Estimate time remaining based on voltage (linear approximation)
                    // 12.2V = ~2:30, 11.8V = ~0:00
                    const voltageRange = LOW_VOLTAGE_THRESHOLD - CRITICAL_VOLTAGE;
                    const voltageRemaining = Math.max(0, voltage - CRITICAL_VOLTAGE);
                    const percentRemaining = voltageRemaining / voltageRange;
                    const totalSeconds = Math.floor(percentRemaining * 150);  // ~2:30 max

                    const mins = Math.floor(totalSeconds / 60);
                    const secs = totalSeconds % 60;

                    elements.statTimeRemaining.textContent = `${mins}:${secs.toString().padStart(2, '0')}`;

                    // Color based on urgency
                    if (voltage <= 12.0) {
                        elements.statTimeRemaining.style.color = 'var(--accent-red)';
                        elements.statVolts.style.color = 'var(--accent-red)';
                    } else {
                        elements.statTimeRemaining.style.color = 'var(--accent-yellow)';
                        elements.statVolts.style.color = 'var(--accent-yellow)';
                    }
                } else if (elements.statTimeRemaining) {
                    // Voltage is good - show OK in green
                    elements.statTimeRemaining.textContent = 'OK';
                    elements.statTimeRemaining.style.color = 'var(--accent-green)';
                    elements.statVolts.style.color = '';  // Reset color
                }
            }

            // Update Trajectory Visualization (legacy - elements may not exist with 3D viewport)
            // Show card when detection is enabled, show overlay when not auto-driving
            if (data.detection_enabled !== undefined && elements.trajectoryCard) {
                elements.trajectoryCard.style.display = data.detection_enabled ? 'block' : 'none';
            }
            if (data.is_auto_driving !== undefined && elements.trajectoryOverlay) {
                elements.trajectoryOverlay.style.display = data.is_auto_driving ? 'none' : 'flex';
            }
            // Draw trajectory when auto-driving (only if legacy function exists)
            if (state.isAutoDriving && data.trajectory && typeof drawTrajectory === 'function') {
                drawTrajectory(data);
            }

            // Update Position Display
            if (data.robot_pose) {
                const rp = data.robot_pose;
                elements.robotX.textContent = `X: ${rp.x.toFixed(1)}`;
                elements.robotY.textContent = `Y: ${rp.y.toFixed(1)}`;
                const thetaDeg = (rp.theta * 180 / Math.PI).toFixed(1);
                elements.robotTheta.textContent = `Œ∏: ${thetaDeg}¬∞`;

                // DEBUG: Log robot_pose data every 30 frames
                if (!window._poseLogCount) window._poseLogCount = 0;
                window._poseLogCount++;
                if (window._poseLogCount % 30 === 0) {
                    console.log('robot_pose:', rp.x.toFixed(1), rp.y.toFixed(1), thetaDeg + '¬∞');
                }

                // Update 3D viewport with robot pose
                update3DScene(rp, data.target_pose, data.nav_phase);
            }
            if (data.target_pose && data.target_pose.x !== null) {
                const tp = data.target_pose;
                elements.targetX.textContent = `X: ${tp.x.toFixed(1)}`;
                elements.targetY.textContent = `Y: ${tp.y.toFixed(1)}`;
                // Calculate distance from robot to target
                if (data.robot_pose) {
                    const dx = tp.x - data.robot_pose.x;
                    const dy = tp.y - data.robot_pose.y;
                    const dist = Math.sqrt(dx * dx + dy * dy);
                    const distIn = (dist / 2.54).toFixed(1);
                    elements.targetDist.textContent = `Dist: ${dist.toFixed(0)}cm (${distIn}in)`;
                }
            } else {
                elements.targetX.textContent = 'X: --';
                elements.targetY.textContent = 'Y: --';
                elements.targetDist.textContent = 'Dist: --';
            }
        }

        function updateDetections(detections) {
            elements.detectionCount.textContent = detections.length;

            if (detections.length === 0) {
                elements.detectionList.innerHTML = '<div class="no-detections">No objects detected</div>';
                return;
            }

            const html = detections.map(d => {
                const distInches = (d.distance_cm / 2.54).toFixed(1);
                const distFeet = (d.distance_cm / 30.48).toFixed(2);
                return `
                <div class="detection-item">
                    <div class="detection-item-label">
                        <span class="detection-badge">${d.label}</span>
                    </div>
                    <div class="detection-item-stats">
                        <span title="Distance">${d.distance_cm.toFixed(0)}cm / ${distInches}in / ${distFeet}ft</span>
                        <span title="Confidence">${(d.confidence * 100).toFixed(0)}%</span>
                        <div class="confidence-bar" title="Confidence">
                            <div class="confidence-fill" style="width: ${d.confidence * 100}%"></div>
                        </div>
                    </div>
                </div>
            `;
            }).join('');

            elements.detectionList.innerHTML = html;
        }

        // =================================================================
        // Lidar Rendering
        // =================================================================
        function drawLidar(points) {
            const canvas = elements.lidarCanvas;
            const ctx = elements.lidarCtx;
            const width = canvas.width;
            const height = canvas.height;
            const cx = width / 2;
            const cy = height / 2;
            const scale = 75; // pixels per meter

            // Clear canvas
            ctx.fillStyle = '#000';
            ctx.fillRect(0, 0, width, height);

            // Draw grid
            ctx.strokeStyle = '#1e293b';
            ctx.lineWidth = 1;

            // Concentric circles (1m, 2m)
            [1, 2].forEach(r => {
                ctx.beginPath();
                ctx.arc(cx, cy, r * scale, 0, Math.PI * 2);
                ctx.stroke();
            });

            // Cross lines
            ctx.beginPath();
            ctx.moveTo(0, cy);
            ctx.lineTo(width, cy);
            ctx.moveTo(cx, 0);
            ctx.lineTo(cx, height);
            ctx.stroke();

            // Draw points
            ctx.fillStyle = '#22c55e';
            points.forEach(point => {
                const x = cx - (point[1] * scale);
                const y = cy - (point[0] * scale);
                ctx.fillRect(x - 1, y - 1, 2, 2);
            });

            // Draw robot center
            ctx.fillStyle = '#ef4444';
            ctx.beginPath();
            ctx.arc(cx, cy, 4, 0, Math.PI * 2);
            ctx.fill();
        }

        // =================================================================
        // Trajectory Rendering
        // =================================================================
        function drawTrajectory(data) {
            const canvas = elements.trajectoryCanvas;
            const ctx = elements.trajectoryCtx;
            const width = canvas.width;
            const height = canvas.height;
            const cx = width / 2;
            const cy = height / 2;

            // Scale: 1 pixel = 1 cm, auto-scale based on trajectory bounds
            let scale = 2.0; // pixels per cm (default)

            // Calculate bounds to auto-scale
            const trajectory = data.trajectory || [];
            const robotPose = data.robot_pose;
            const targetPose = data.target_pose;
            const startPos = data.auto_drive_start;

            if (trajectory.length > 0) {
                let maxDist = 50; // minimum 50cm view
                trajectory.forEach(p => {
                    const dist = Math.sqrt(p[0] * p[0] + p[1] * p[1]);
                    if (dist > maxDist) maxDist = dist;
                });
                if (targetPose && targetPose.x !== null) {
                    const targetDist = Math.sqrt(targetPose.x * targetPose.x + targetPose.y * targetPose.y);
                    if (targetDist > maxDist) maxDist = targetDist;
                }
                scale = (width / 2 - 20) / maxDist; // Leave 20px margin
            }

            // Clear canvas
            ctx.fillStyle = '#0f172a';
            ctx.fillRect(0, 0, width, height);

            // Draw grid
            ctx.strokeStyle = '#1e293b';
            ctx.lineWidth = 1;

            // Concentric circles (50cm, 100cm)
            [50, 100, 150].forEach(r => {
                ctx.beginPath();
                ctx.arc(cx, cy, r * scale, 0, Math.PI * 2);
                ctx.stroke();
            });

            // Cross lines
            ctx.beginPath();
            ctx.moveTo(0, cy);
            ctx.lineTo(width, cy);
            ctx.moveTo(cx, 0);
            ctx.lineTo(cx, height);
            ctx.stroke();

            // Draw trajectory path (green line)
            if (trajectory.length > 1) {
                ctx.strokeStyle = '#22c55e';
                ctx.lineWidth = 2;
                ctx.beginPath();
                const first = trajectory[0];
                ctx.moveTo(cx + first[0] * scale, cy - first[1] * scale);
                trajectory.forEach(p => {
                    ctx.lineTo(cx + p[0] * scale, cy - p[1] * scale);
                });
                ctx.stroke();
            }

            // Draw planned path to target (blue dashed line)
            if (robotPose && targetPose && targetPose.x !== null) {
                ctx.strokeStyle = '#06b6d4';
                ctx.lineWidth = 2;
                ctx.setLineDash([5, 5]);
                ctx.beginPath();
                ctx.moveTo(cx + robotPose.x * scale, cy - robotPose.y * scale);
                ctx.lineTo(cx + targetPose.x * scale, cy - targetPose.y * scale);
                ctx.stroke();
                ctx.setLineDash([]);
            }

            // Draw start position (white circle)
            if (startPos) {
                ctx.fillStyle = '#ffffff';
                ctx.beginPath();
                ctx.arc(cx + startPos.x * scale, cy - startPos.y * scale, 6, 0, Math.PI * 2);
                ctx.fill();
            }

            // Draw target position (yellow star/circle)
            if (targetPose && targetPose.x !== null) {
                ctx.fillStyle = '#eab308';
                ctx.beginPath();
                ctx.arc(cx + targetPose.x * scale, cy - targetPose.y * scale, 8, 0, Math.PI * 2);
                ctx.fill();
            }

            // Draw robot current position (red circle with heading indicator)
            if (robotPose) {
                const rx = cx + robotPose.x * scale;
                const ry = cy - robotPose.y * scale;

                // Heading line
                ctx.strokeStyle = '#ef4444';
                ctx.lineWidth = 2;
                ctx.beginPath();
                ctx.moveTo(rx, ry);
                ctx.lineTo(rx + Math.cos(robotPose.theta) * 15, ry - Math.sin(robotPose.theta) * 15);
                ctx.stroke();

                // Robot body
                ctx.fillStyle = '#ef4444';
                ctx.beginPath();
                ctx.arc(rx, ry, 5, 0, Math.PI * 2);
                ctx.fill();
            }
        }

        function updateAutoDriveButton() {
            if (state.isAutoDriving) {
                elements.autoDriveBtn.textContent = "Stop Auto-Drive";
                elements.autoDriveBtn.classList.add("btn-danger");
                elements.autoDriveBtn.classList.remove("btn-primary");
            } else {
                elements.autoDriveBtn.textContent = "Start Auto-Drive";
                elements.autoDriveBtn.classList.remove("btn-danger");
                elements.autoDriveBtn.classList.add("btn-primary");
            }
        }

        // =================================================================
        // Motor Control
        // =================================================================
        function handleSliderInput(event) {
            const slider = event.target;
            const power = parseFloat(slider.value) / 100;
            const motorId = slider.id.includes('left') ? 'left' : 'right';

            if (motorId === 'left') {
                elements.leftSliderValue.textContent = slider.value;
            } else {
                elements.rightSliderValue.textContent = slider.value;
            }

            sendMessage({
                type: "set_power",
                motor: motorId,
                power: power
            });
        }

        function stopMotors() {
            sendMessage({ type: "stop" });

            elements.leftSlider.value = 0;
            elements.rightSlider.value = 0;
            elements.leftSliderValue.textContent = '0';
            elements.rightSliderValue.textContent = '0';
        }

        // =================================================================
        // Toggle Handlers
        // =================================================================
        function toggleDetection() {
            state.detectionEnabled = !state.detectionEnabled;
            elements.detectionToggle.classList.toggle('active', state.detectionEnabled);
            elements.detectionPanel.style.display = state.detectionEnabled ? 'block' : 'none';

            sendMessage({
                type: "toggle_detection",
                enabled: state.detectionEnabled
            });
        }

        function toggleLidar() {
            state.lidarEnabled = !state.lidarEnabled;
            elements.lidarToggle.classList.toggle('active', state.lidarEnabled);

            if (!state.lidarEnabled) {
                // Clear canvas when disabled
                const ctx = elements.lidarCtx;
                ctx.fillStyle = '#000';
                ctx.fillRect(0, 0, elements.lidarCanvas.width, elements.lidarCanvas.height);
            }
        }

        // =================================================================
        // Gamepad Support
        // =================================================================
        let gamepadPollingInterval = null;
        let buttonDebounce = { square: false, triangle: false };

        window.addEventListener("gamepadconnected", (e) => {
            state.gamepadIndex = e.gamepad.index;
            elements.controllerName.textContent = e.gamepad.id.substring(0, 30);
            elements.controllerName.classList.remove('text-muted');
            elements.controllerName.style.color = 'var(--accent-green)';

            // Update header indicator
            const indicator = document.getElementById('gamepad-indicator');
            const statusText = document.getElementById('gamepad-status-text');
            indicator.style.background = 'var(--bg-secondary)';
            indicator.style.border = '1px solid var(--accent-green)';
            statusText.textContent = '‚úì Connected';
            statusText.style.color = 'var(--accent-green)';

            if (!gamepadPollingInterval) {
                gamepadPollingInterval = setInterval(pollGamepad, 50);
            }
        });

        window.addEventListener("gamepaddisconnected", (e) => {
            if (state.gamepadIndex === e.gamepad.index) {
                state.gamepadIndex = null;
                elements.controllerName.textContent = 'Controller disconnected';
                elements.controllerName.style.color = 'var(--accent-red)';

                // Update header indicator
                const indicator = document.getElementById('gamepad-indicator');
                const statusText = document.getElementById('gamepad-status-text');
                indicator.style.background = 'var(--bg-tertiary)';
                indicator.style.border = 'none';
                statusText.textContent = 'No Controller';
                statusText.style.color = 'var(--text-muted)';

                stopMotors();
            }
        });

        function pollGamepad() {
            if (state.gamepadIndex === null || !state.connected) return;

            const gamepad = navigator.getGamepads()[state.gamepadIndex];
            if (!gamepad) return;

            // Button mappings (PS4/PS5 layout):
            // 0 = X (Cross) - E-Stop
            // 1 = Circle
            // 2 = Square - Toggle Detection
            // 3 = Triangle - Toggle Auto-Drive

            // E-Stop (X/Cross button)
            if (gamepad.buttons[0].pressed) {
                stopMotors();
                return;
            }

            // Square button - Toggle Detection
            if (gamepad.buttons[2].pressed && !buttonDebounce.square) {
                buttonDebounce.square = true;
                const newState = !state.detectionEnabled;
                elements.detectionToggle.classList.toggle('active', newState);
                state.detectionEnabled = newState;
                sendMessage({ type: "toggle_detection", enabled: newState });
                console.log('üéÆ Square: Detection', newState ? 'ON' : 'OFF');
            } else if (!gamepad.buttons[2].pressed) {
                buttonDebounce.square = false;
            }

            // Triangle button - Toggle Auto-Drive (only if detection is enabled)
            if (gamepad.buttons[3].pressed && !buttonDebounce.triangle) {
                buttonDebounce.triangle = true;
                if (state.detectionEnabled) {
                    if (!state.autoDriveEnabled) {
                        // Start auto-drive
                        sendMessage({ type: "start_auto_drive" });
                        state.autoDriveEnabled = true;
                        elements.autoDriveToggle.classList.add('active');
                        console.log('üéÆ Triangle: Auto-Drive ON');
                    } else {
                        // Stop auto-drive
                        sendMessage({ type: "stop_auto_drive" });
                        state.autoDriveEnabled = false;
                        elements.autoDriveToggle.classList.remove('active');
                        console.log('üéÆ Triangle: Auto-Drive OFF');
                    }
                } else {
                    console.log('üéÆ Triangle: Detection must be ON first!');
                }
            } else if (!gamepad.buttons[3].pressed) {
                buttonDebounce.triangle = false;
            }

            // Right stick for arcade drive (only if NOT in auto-drive mode)
            if (!state.autoDriveEnabled) {
                const deadzone = 0.1;
                let rx = gamepad.axes[2];
                let ry = gamepad.axes[3];

                if (Math.abs(rx) < deadzone) rx = 0;
                if (Math.abs(ry) < deadzone) ry = 0;

                const throttle = -ry;
                const turn = rx;

                let leftPower = Math.max(-1, Math.min(1, throttle + turn));
                let rightPower = Math.max(-1, Math.min(1, throttle - turn));

                // Only send if changed significantly
                if (Math.abs(leftPower - state.lastLeftPower) > 0.02 ||
                    Math.abs(rightPower - state.lastRightPower) > 0.02) {

                    sendMessage({ type: "set_power", motor: "left", power: leftPower });
                    sendMessage({ type: "set_power", motor: "right", power: rightPower });

                    state.lastLeftPower = leftPower;
                    state.lastRightPower = rightPower;

                    // Update UI
                    elements.leftSlider.value = Math.round(leftPower * 100);
                    elements.rightSlider.value = Math.round(rightPower * 100);
                    elements.leftSliderValue.textContent = elements.leftSlider.value;
                    elements.rightSliderValue.textContent = elements.rightSlider.value;
                }
            }
        }

        function updateVisuals(value, fill, thumb) {
            // Value is -100 to 100
            // Normalize to 0-1 range for position
            const pct = (parseInt(value) + 100) / 200;
            const pctString = (pct * 100) + "%";

            // Move thumb
            thumb.style.bottom = pctString;

            // Adjust Fill (Center-Zero logic)
            // Center is 50%
            if (value >= 0) {
                fill.style.bottom = "50%";
                fill.style.height = (value / 2) + "%";
                fill.style.backgroundColor = "var(--accent-green)"; // Positive color
            } else {
                // Negative
                // Bottom is current % position, Height is abs(value)/2
                // e.g. -50% -> val=-50 -> pct=25% -> bottom=25%, height=25% (reaching 50%)
                // Wait, simpler:
                // fill.style.bottom = (50 - abs(val)/2) % ? No.
                // Just set top/bottom based on range.
                // It's easier to anchor to 50% and grow Down?
                // But structure is absolute bottom.
                // Let's use Top/Bottom/Height calc.

                // If negative: Bottom = (pct * 100)%, Height = (Math.abs(value)/2)%
                const absVal = Math.abs(value);
                fill.style.bottom = pctString;
                fill.style.height = (absVal / 2) + "%";
                fill.style.backgroundColor = "var(--accent-cyan)"; // Negative color
            }
        }

        // =================================================================
        // Event Listeners
        // =================================================================

        // Connect
        elements.connectBtn.addEventListener('click', () => {
            if (state.connected) {
                state.ws.close();
            } else {
                connect();
            }
        });

        // Motor Control (Sliders)
        function updateMotor(motor, value) {
            if (!state.connected || state.isAutoDriving) return;

            const power = value / 100.0;
            const msg = {
                type: "set_power",
                motor: motor,
                power: power
            };

            if (state.ws && state.ws.readyState === WebSocket.OPEN) {
                state.ws.send(JSON.stringify(msg));
            }
        }

        elements.leftSlider.addEventListener('input', (e) => {
            const val = e.target.value;
            elements.leftSliderValue.textContent = val;
            updateVisuals(val, elements.leftFill, elements.leftThumb);
            updateMotor('left', parseInt(val));
        });

        elements.leftSlider.addEventListener('change', (e) => {
            // Optional: Return to 0 on release? User preference.
            // For now, it stays where you put it.
        });

        elements.rightSlider.addEventListener('input', (e) => {
            const val = e.target.value;
            elements.rightSliderValue.textContent = val;
            updateVisuals(val, elements.rightFill, elements.rightThumb);
            updateMotor('right', parseInt(val));
        });

        // Initialize visuals
        updateVisuals(0, elements.leftFill, elements.leftThumb);
        updateVisuals(0, elements.rightFill, elements.rightThumb);

        // Stop Button
        elements.stopBtn.addEventListener('click', () => {
            if (!state.connected) return;

            // Send stop command
            state.ws.send(JSON.stringify({ type: "stop" }));

            // Also stop auto-drive if active
            if (state.isAutoDriving) {
                state.ws.send(JSON.stringify({ type: "stop_auto_drive" }));
            }

            // Reset UI
            elements.leftSlider.value = 0;
            elements.leftSliderValue.textContent = "0";
            updateVisuals(0, elements.leftFill, elements.leftThumb);

            elements.rightSlider.value = 0;
            elements.rightSliderValue.textContent = "0";
            updateVisuals(0, elements.rightFill, elements.rightThumb);
        });


        // Auto Drive Button
        elements.autoDriveBtn.addEventListener('click', () => {
            if (!state.connected) return;

            const msgType = state.isAutoDriving ? "stop_auto_drive" : "start_auto_drive";
            state.ws.send(JSON.stringify({ type: msgType }));
        });

        // Capture Image Button
        elements.captureBtn.addEventListener('click', () => {
            if (!state.connected) return;
            state.ws.send(JSON.stringify({ type: "capture_image" }));
            // Temporarily disable button to prevent spam
            elements.captureBtn.disabled = true;
            elements.captureBtn.textContent = '‚è≥ Saving...';
            setTimeout(() => {
                elements.captureBtn.disabled = false;
                elements.captureBtn.textContent = 'üì∏ Capture';
            }, 500);
        });

        // Disconnect Button
        elements.disconnectBtn.addEventListener('click', () => {
            if (!state.connected || !state.ws) return;

            // Send disconnect command to server
            state.ws.send(JSON.stringify({ type: "disconnect" }));

            // Close WebSocket from client side
            state.ws.close();
            state.connected = false;
            state.ws = null;

            // Update UI
            updateConnectionStatus('disconnected');
            elements.disconnectBtn.style.display = 'none';
            elements.controlArea.classList.add('disabled-overlay');
        });

        // Toggles
        elements.detectionToggle.addEventListener('click', () => {
            if (!state.connected) return;

            const newState = !state.detectionEnabled;
            // Optimistically update
            state.detectionEnabled = newState;
            elements.detectionToggle.classList.toggle('active', newState);

            // Toggle Auto-Drive Button
            if (newState) {
                elements.autoDriveWrapper.classList.add('visible');
            } else {
                elements.autoDriveWrapper.classList.remove('visible');
                // Also stop auto-drive if we disabled detection?
                // Typically yes, but user might want manual control.
                // Let's leave state alone but hide button.
            }

            state.ws.send(JSON.stringify({
                type: "toggle_detection",
                enabled: newState
            }));
        });

        elements.lidarToggle.addEventListener('click', () => {
            state.lidarEnabled = !state.lidarEnabled;
            elements.lidarToggle.classList.toggle('active', state.lidarEnabled);
        });

        // =================================================================
        // Initialization
        // =================================================================
        // Check for gamepad connection
        window.addEventListener("gamepadconnected", (e) => {
            state.gamepadIndex = e.gamepad.index;
            document.getElementById('controller-name').textContent = e.gamepad.id; // Corrected ID
            document.getElementById('controller-status').style.background = "var(--bg-secondary)";
            // Start polling
            requestAnimationFrame(gamepadLoop);
        });

        window.addEventListener("gamepaddisconnected", (e) => {
            state.gamepadIndex = null;
            document.getElementById('controller-name').textContent = "No controller detected";
            document.getElementById('controller-status').style.background = "var(--bg-tertiary)";
        });

        function gamepadLoop() {
            if (state.gamepadIndex !== null) {
                const gp = navigator.getGamepads()[state.gamepadIndex];
                if (gp) {
                    // Right Stick Y-axis (Index 3) for forward/back
                    // Right Stick X-axis (Index 2) for turn
                    // NOTE: Axis values are -1 to 1.
                    // Y: -1 is Up (usually), 1 is Down

                    const fwd = -gp.axes[3]; // Invert so Up is positive
                    const turn = gp.axes[2];

                    // Deadzone
                    const deadzone = 0.1;
                    const cleanFwd = Math.abs(fwd) < deadzone ? 0 : fwd;
                    const cleanTurn = Math.abs(turn) < deadzone ? 0 : turn;

                    // Mixing (Arcade Drive)
                    // Left = Fwd + Turn
                    // Right = Fwd - Turn
                    let left = cleanFwd + cleanTurn;
                    let right = cleanFwd - cleanTurn;

                    // Clamp
                    left = Math.max(Math.min(left, 1), -1);
                    right = Math.max(Math.min(right, 1), -1);

                    // Emergency Stop (Button 0 = Cross/A)
                    if (gp.buttons[0].pressed) {
                        // Emergency Stop or Cross
                        if (state.connected) {
                            state.ws.send(JSON.stringify({ type: "stop" }));
                            if (state.isAutoDriving) {
                                state.ws.send(JSON.stringify({ type: "stop_auto_drive" }));
                            }
                            elements.leftSlider.value = 0;
                            elements.leftSliderValue.textContent = "0";
                            updateVisuals(0, elements.leftFill, elements.leftThumb);
                            elements.rightSlider.value = 0;
                            elements.rightSliderValue.textContent = "0";
                            updateVisuals(0, elements.rightFill, elements.rightThumb);
                        }
                    } else if (!state.isAutoDriving && (Math.abs(left) > 0.05 || Math.abs(right) > 0.05)) {
                        // Only send if stick moved and NOT auto-driving
                        // Update UI sliders too
                        const lVal = Math.round(left * 100);
                        const rVal = Math.round(right * 100);

                        elements.leftSlider.value = lVal;
                        elements.leftSliderValue.textContent = lVal;
                        updateVisuals(lVal, elements.leftFill, elements.leftThumb);

                        elements.rightSlider.value = rVal;
                        elements.rightSliderValue.textContent = rVal;
                        updateVisuals(rVal, elements.rightFill, elements.rightThumb);

                        const msg = { type: "set_power", motor: "left", power: left };
                        const msg2 = { type: "set_power", motor: "right", power: right };

                        if (state.connected && state.ws && state.ws.readyState === WebSocket.OPEN) {
                            state.ws.send(JSON.stringify(msg));
                            state.ws.send(JSON.stringify(msg2));
                        }
                    }
                }
                requestAnimationFrame(gamepadLoop);
            }
        }

        // =================================================================
        // WASD / D-PAD LOGIC
        // =================================================================

        // Power Slider
        elements.keyPower.addEventListener('input', (e) => {
            elements.keyPowerVal.textContent = e.target.value;
        });

        // Helper to send move command
        function sendMove(leftMult, rightMult) {
            if (!state.connected || state.isAutoDriving) return;

            const basePower = parseFloat(elements.keyPower.value);
            const lPwr = basePower * leftMult;
            const rPwr = basePower * rightMult;

            // Update UI sliders to reflect what's happening
            const lVal = Math.round(lPwr * 100);
            const rVal = Math.round(rPwr * 100);

            elements.leftSlider.value = lVal;
            elements.leftSliderValue.textContent = lVal;
            updateVisuals(lVal, elements.leftFill, elements.leftThumb);

            elements.rightSlider.value = rVal;
            elements.rightSliderValue.textContent = rVal;
            updateVisuals(rVal, elements.rightFill, elements.rightThumb);

            // Send
            const msg1 = { type: "set_power", motor: "left", power: lPwr };
            const msg2 = { type: "set_power", motor: "right", power: rPwr };

            if (state.ws && state.ws.readyState === WebSocket.OPEN) {
                state.ws.send(JSON.stringify(msg1));
                state.ws.send(JSON.stringify(msg2));
            }
        }

        function stopMove() {
            if (!state.connected) return;
            // Stop
            state.ws.send(JSON.stringify({ type: "stop" }));

            // Reset UI
            elements.leftSlider.value = 0;
            elements.leftSliderValue.textContent = "0";
            updateVisuals(0, elements.leftFill, elements.leftThumb);
            elements.rightSlider.value = 0;
            elements.rightSliderValue.textContent = "0";
            updateVisuals(0, elements.rightFill, elements.rightThumb);
        }

        // D-Pad Mouse Events
        const dPadButtons = [
            { el: elements.btnW, l: 1, r: 1 },    // Forward
            { el: elements.btnS, l: -1, r: -1 },  // Backward
            { el: elements.btnA, l: -1, r: 1 },   // Left (Pivot)
            { el: elements.btnD, l: 1, r: -1 }    // Right (Pivot)
        ];

        dPadButtons.forEach(btn => {
            // Mouse
            btn.el.addEventListener('mousedown', () => sendMove(btn.l, btn.r));
            btn.el.addEventListener('mouseup', stopMove);
            btn.el.addEventListener('mouseleave', stopMove);

            // Touch
            btn.el.addEventListener('touchstart', (e) => { e.preventDefault(); sendMove(btn.l, btn.r); });
            btn.el.addEventListener('touchend', (e) => { e.preventDefault(); stopMove(); });
        });

        // Keyboard Events
        const keysPressed = {};

        window.addEventListener('keydown', (e) => {
            if (!state.connected || state.isAutoDriving) return;
            // Only if toggle is ON
            if (!elements.keyboardToggle.checked) return;

            const key = e.key.toLowerCase();
            if (keysPressed[key]) return; // Ignore repeat
            keysPressed[key] = true;

            // Prioritize: W/S > A/D
            // Simple mapping for verification
            if (key === 'w' || key === 'arrowup') {
                elements.btnW.classList.add('active');
                sendMove(1, 1);
            } else if (key === 's' || key === 'arrowdown') {
                elements.btnS.classList.add('active');
                sendMove(-1, -1);
            } else if (key === 'a' || key === 'arrowleft') {
                elements.btnA.classList.add('active');
                sendMove(-1, 1); // Pivot Left
            } else if (key === 'd' || key === 'arrowright') {
                elements.btnD.classList.add('active');
                sendMove(1, -1); // Pivot Right
            }
        });

        window.addEventListener('keyup', (e) => {
            const key = e.key.toLowerCase();
            keysPressed[key] = false;

            // Remove active classes
            if (key === 'w' || key === 'arrowup') elements.btnW.classList.remove('active');
            if (key === 's' || key === 'arrowdown') elements.btnS.classList.remove('active');
            if (key === 'a' || key === 'arrowleft') elements.btnA.classList.remove('active');
            if (key === 'd' || key === 'arrowright') elements.btnD.classList.remove('active');

            // If toggle is off, ignore
            if (!elements.keyboardToggle.checked) return;

            // Simple stop on key up logic might be glitchy if multiple keys held.
            // For robust WASD, usually check state of all keys.
            // But for simple "Quick move", we usually just stop if the primary key is lifted.
            // Or check if ANY move keys are still down?

            const moveKeys = ['w', 'a', 's', 'd', 'arrowup', 'arrowdown', 'arrowleft', 'arrowright'];
            const anyPressed = moveKeys.some(k => keysPressed[k]);

            if (!anyPressed) {
                stopMove();
            } else {
                // Re-evaluate?
                // E.g. Holding W and A, release A -> Should continue W?
                // For now, Keep it simple. If I release A but W is held, I might want to go back to Forward.
                if (keysPressed['w'] || keysPressed['arrowup']) sendMove(1, 1);
                else if (keysPressed['s'] || keysPressed['arrowdown']) sendMove(-1, -1);
                else if (keysPressed['a'] || keysPressed['arrowleft']) sendMove(-1, 1);
                else if (keysPressed['d'] || keysPressed['arrowright']) sendMove(1, -1);
            }
        });
    </script>
</body>

</html>
```